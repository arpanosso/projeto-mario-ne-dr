---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, warning = FALSE, erro=FALSE, message = FALSE,
  comment = "#>"
)
```

## APRENDIZADO DE MÁQUINA PARA PREDIÇÃO DA VARIABILIDADE ESPAÇO-TEMPORAL DA PRODUÇÃO DE CANA-DE-AÇÚCAR

## Carregando pacotes

```{r}
library(tidyverse)
library(ggridges)
library(vegan)
library(corrplot)
theme_set(theme_bw())
```


## Lendo o banco de dados

```{r}
data_set <- read_rds("data/sugarcane-soil.rds")  |> 
  rename_with(~ str_replace(., "_2$", ""), ends_with("_2"))
glimpse(data_set)
```

## 1. Análise Estatística Exploratória

Tabela com a estatística descritiva por unidade (CAT e POT) para as variáveis numéricas (n, min, q1, mediana, média, q3, max, dp, epm, cv, cassimetria, ccurtose) para as variáveis `tch_real` até `s_2`...nos diferentes tempos, pra caracterizarmos a variabilidade total do conjunto de dados

criando a função para a análise exploratória dos dados

```{r}
estat_desc <- function(x){
  set.seed(1235)
  xs <- sample(x,500)
  normal <- nortest::lillie.test(xs)
  log_norm <- nortest::lillie.test(log(xs+1))
  n <- length(x)
  m <- mean(x,na.rm = TRUE)
  md <- median(x)
  mini <- min(x,na.rm = TRUE)
  q1 <- quantile(x,.25)
  q3 <- quantile(x,.75)
  maxi <- max(x,na.rm = TRUE)
  dp <- sd(x,na.rm = TRUE)
  epm <- dp/sqrt(n)
  cv <- 100*dp/m
  ass <- agricolae::skewness(x)
  curt <- agricolae::kurtosis(x)
  c(n,mini,q1,md,m,q3,maxi,dp,epm,cv,ass,curt,normal$p.value,log_norm$p.value)
}
estat_names <- c("n","Min","Q1","Med","Média","Q3",
                 "Max","DP","EP","CV","Skn","Krt","norm","log_norm")
```


Tabela de estatística descritiva presente no arquivo do excel na pasta `output`.

```{r}
data_set |> 
  group_by(ano,unidade) |> 
  reframe(
    across(.cols = tch_real:s,
           .fns = estat_desc,
           .names = "{.col}")
  )|> 
  add_column(estatistica = rep(estat_names,2*3)) |> 
  relocate(estatistica) |> 
  writexl::write_xlsx("output/estat-desc.xlsx")
```

Boxplot para comparação

```{r}
var_names <- data_set |> select(tch_real:s) |> names()
map(var_names, ~{
    x<-data_set |> pull(!!sym(.x))
  q3 <- quantile(x,0.99)
  data_set |> 
    filter(!!sym(.x) <= q3) |>  
  ggplot(aes(x=as_factor(ano),y=!!sym(.x),fill=unidade)) +
  geom_boxplot() +
  scale_fill_manual(values=c("#009E73", "#D55E00")) +
  labs(x="Ano", y=.x)
})
```
```{r}
map(var_names, ~{
  x<-data_set |> pull(!!sym(.x))
  q3 <- quantile(x,0.99)
  data_set |> 
    filter(!!sym(.x) <= q3) |> 
    ggplot(aes(x=!!sym(.x),fill=unidade)) +
    geom_histogram(color="black") +
    scale_fill_manual(values=c("#009E73", "#D55E00")) +
    labs(x="Ano", y=.x)+
    facet_wrap(~ano,ncol=2)
})
```
```{r}
map(var_names, ~{
  x<-data_set |> pull(!!sym(.x))
  q3 <- quantile(x,0.99)
  data_set |> 
    filter(!!sym(.x) <= q3) |> 
    ggplot(aes(y=as_factor(ano))) +
    geom_density_ridges(rel_min_height = 0.03,
                        aes(x=!!sym(.x), fill=unidade),
                        alpha = .6, color = "black"
    ) +
    scale_fill_cyclical(values = c("#ff8080","#238B45"),
                        name = "classe", guide = "legend") +
    labs(y="Ano", x=.x)+
    theme_ridges()
})
```


### Dados transformados com log

```{r}
map(var_names, ~{
  x<-data_set |> pull(!!sym(.x))
  x<-log(x+1)
  q3 <- quantile(x,0.99)
  data_set |> 
    mutate(!!sym(.x) := log(!!sym(.x) +1)) |> 
    # filter(!!sym(.x) <= q3) |> 
    ggplot(aes(x=!!sym(.x),fill=unidade)) +
    geom_histogram(color="black") +
    scale_fill_manual(values=c("#009E73", "#D55E00")) +
    labs(x="Ano", y=paste0("log(",.x,"+1)"))+
    facet_wrap(~ano,ncol=2)
})
```

## 2. Matriz de correlação linear (corplot) fazer por ano (2016, 2017 e 2018) e por UNIDADE


Para CAT
```{r}
map(2016:2018, ~{data_set |> filter(unidade == "CAT") |>  
    rename(TCH = tch_real,
           Ca = ca,
           `m%` = m,
           SB = sb,
           CTC = ctc,
           P = p_resina,
           `H+Al` = h_al,
           `V%` = v,
           K = k,
           Mg = mg,
           MO = mo,
           pH = ph_cacl2,
           S = s) |> 
  filter(ano == .x) |> 
  select(TCH:S) |> 
  cor() |> 
  corrplot::corrplot( method = "color",
         outline = T,,
         addgrid.col = "darkgray",cl.pos = "r", tl.col = "black",
         tl.cex = 1, cl.cex = 1, type = "upper", bg="azure2",
         diag = FALSE,
         addCoef.col = "black",
         cl.ratio = 0.2,
         cl.length = 5,
         number.cex = 0.8)}) 
```

Para POT
```{r}
map(2016:2018, ~{data_set |> filter(unidade == "POT") |>  
    rename(TCH = tch_real,
           Ca = ca,
           `m%` = m,
           SB = sb,
           CTC = ctc,
           P = p_resina,
           `H+Al` = h_al,
           `V%` = v,
           K = k,
           Mg = mg,
           MO = mo,
           pH = ph_cacl2,
           S = s) |> 
  filter(ano == .x) |> 
  select(TCH:S) |> 
  cor() |> 
  corrplot::corrplot( method = "color",
         outline = T,,
         addgrid.col = "darkgray",cl.pos = "r", tl.col = "black",
         tl.cex = 1, cl.cex = 1, type = "upper", bg="azure2",
         diag = FALSE,
         addCoef.col = "black",
         cl.ratio = 0.2,
         cl.length = 5,
         number.cex = 0.8)}) 
```

### 2.1 Análise de agrupamento independente do ano

```{r}
da <- data_set |> 
      rename(TCH = tch_real,
           Ca = ca,
           `m%` = m,
           SB = sb,
           CTC = ctc,
           P = p_resina,
           `H+Al` = h_al,
           `V%` = v,
           K = k,
           Mg = mg,
           MO = mo,
           pH = ph_cacl2,
           S = s) |> 
  group_by(x,y) |> 
  summarise(
    across(.cols = TCH:S,
           .fns = mean,
           .names = "{.col}"),
    .groups = "drop"
  ) |> select(-x,-y)

da_pad <- decostand(da, 
                  method = "standardize",
                  na.rm=TRUE)
da_pad_euc <- vegdist(da_pad, "euclidean") 
da_pad_euc_ward<-hclust(da_pad_euc, method="ward.D")
plot(da_pad_euc_ward, 
     ylab="Distância Euclidiana",
     xlab="Acessos", hang=-1,
     col="blue", las=1,
     cex=.6,lwd=1.5);box()
grupo <- cutree(da_pad_euc_ward,3)
```



### 2.2 análise de componentes principais ano (2016 e 2017) e por UNIDADE

```{r}
print("======== Análise de Componentes Principais ========== ")
pca <-  prcomp(da_pad,scale.=TRUE)
# Autovalores
eig<-pca$sdev^2
print("==== Autovalores ====")
print(round(eig,3))
print("==== % da variância explicada ====")
ve<-eig/sum(eig)
print(round(ve,4))
print("==== % da variância explicada acumulada ====")
print(round(cumsum(ve),4)*100)
print("==== Poder Discriminante ====")
mcor<-cor(da_pad,pca$x)
corrplot(mcor)
print("==== screeplot ====")
screeplot(pca)
abline(h=1)
```

```{r}
pc1V<-cor(da_pad,pca$x)[,1]/sd(cor(da_pad,pca$x)[,1])
pc2V<-cor(da_pad,pca$x)[,2]/sd(cor(da_pad,pca$x)[,2])
pc3V<-cor(da_pad,pca$x)[,3]/sd(cor(da_pad,pca$x)[,3])
pc1c<-pca$x[,1]/sd(pca$x[,1])
pc2c<-pca$x[,2]/sd(pca$x[,2])
pc3c<-pca$x[,3]/sd(pca$x[,3])
nv<-ncol(da) # número de variáveis utilizadas na análise
```

```{r}
# gráfico biplot
bip<-data.frame(pc1c,pc2c,pc3c,grupo)
texto <- data.frame(
  x = pc1V,
  y = pc2V,
  z = pc3V,
  label = names(da)
)

bi_plot <- bip |> 
  ggplot(aes(x=pc1c,y=pc2c,color = as_factor(grupo)))+
  geom_point() + 
  theme_minimal() +
   scale_shape_manual(values=16:18)+
  scale_color_manual(values=c("#009E73", "#999999","#D55E00")) +
  annotate(geom="text", x=pc1V, y=pc2V, label=names(pc1V),
              color="black",font=3)+
  geom_vline(aes(xintercept=0),
             color="black", size=1)+
  geom_hline(aes(yintercept=0),
             color="black", size=1)+
  annotate(geom="segment",
           x=rep(0,length(da)),
           xend=texto$x,
           y=rep(0,length(da)),
           yend=texto$y,color="black",lwd=.5)+
  geom_label(data=texto,aes(x=x,y=y,label=label),
             color="black",angle=0,fontface="bold",size=4,fill="white")+
  labs(x=paste("CP1 (",round(100*ve[1],2),"%)",sep=""),
       y=paste("CP2 (",round(100*ve[2],2),"%)",sep=""),
       color="",shape="")+
  theme(legend.position = "top")
bi_plot +
  coord_cartesian(
    xlim = c(-4,3),
    ylim = c(-3,8)
  )
```

```{r}
# gráfico biplot
bi_plot_2 <- bip |> 
  ggplot(aes(x=pc1c,y=pc3c,color = as_factor(grupo)))+
  geom_point() + 
  theme_minimal() +
  scale_shape_manual(values=16:18)+
  scale_color_manual(values=c("#009E73", "#999999","#D55E00")) +
  annotate(geom="text", x=pc1V, y=pc3V, label=names(pc1V),
              color="black",font=3)+
  geom_vline(aes(xintercept=0),
             color="black", size=1)+
  geom_hline(aes(yintercept=0),
             color="black", size=1)+
  annotate(geom="segment",
           x=rep(0,length(da)),
           xend=texto$x,
           y=rep(0,length(da)),
           yend=texto$z,color="black",lwd=.5)+
  geom_label(data=texto,aes(x=x,y=z,label=label),
             color="black",angle=0,fontface="bold",size=4,fill="white")+
  labs(x=paste("CP1 (",round(100*ve[1],2),"%)",sep=""),
       y=paste("CP3 (",round(100*ve[3],2),"%)",sep=""),
       color="",shape="")+
  theme(legend.position = "top")
bi_plot_2 +
  coord_cartesian(
    xlim = c(-4,3),
    ylim = c(-3,8)
  )
```
```{r}
 data_set |> 
  group_by(x,y) |> 
  summarise(
    across(.cols = tch_real:s,
           .fns = mean,
           .names = "{.col}"),
    .groups = "drop"
  ) |> 
  add_column(grupo) |> 
  ggplot(aes(x=x,y=y,color=as_factor(grupo))) +
  geom_point() +
  scale_shape_manual(values=16:18)+
  scale_color_manual(values=c("#009E73", "#999999","#D55E00")) 
```


## 3. Análise e modelagem geoestatística (2016 e 2017) e por UNIDADE.

## 4. Aprendizado de máquina com validação final a partir dos dados de 2018 e por UNIDADE
